<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>æ‰é‡‘èŠ± Â· å…«åº§ä½ï¼ˆé—·/çœ‹ç‰ŒåŒå€æ³¨ç‰ˆï¼‰</title>

  <!-- å¯é€‰ï¼šPWAï¼ˆè‹¥æ²¡æœ‰å¯å…ˆæ³¨é‡Šï¼‰ -->
  <link rel="manifest" href="./manifest.json" />
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js', { scope: './' }).catch(console.error);
      });
    }
  </script>

  <style>
    :root{
      --bg:#0b1020; --felt:#0d1b2a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb;
      --accent:#22d3ee; --danger:#f43f5e; --ok:#10b981; --warn:#f59e0b; --border:#293241;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:8px;display:grid;gap:8px}

    .topbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{padding:3px 8px;border:1px solid var(--border);border-radius:10px;background:#0f172a;font-size:12px}
    .pot{font-weight:700;color:var(--accent)}
    .turn{color:var(--warn);font-weight:700}
    .ghost{opacity:.75}
    .btn{padding:6px 10px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:12px}

    .table{
      position:relative;height:520px;border:1px solid var(--border);border-radius:16px;
      background: radial-gradient(ellipse at center,#0f2a2a 0%, var(--felt) 60%, #0b1328 100%);
      overflow:hidden;
    }
    .seats{position:absolute; inset:0;}
    .center-pot{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(15,23,42,.85); border:1px solid var(--border); border-radius:10px;
      padding:4px 10px; font-size:13px; color:#e5e7eb; box-shadow:0 6px 16px rgba(0,0,0,.25);
    }

    .seat{
      position:absolute;width:150px;max-width:26vw;border:1px solid var(--border);
      border-radius:10px;background:var(--panel);padding:6px;box-shadow:0 6px 16px rgba(0,0,0,.2)
    }
    .seat h3{margin:0 0 4px;font-size:12px;display:flex;align-items:center;gap:6px}
    .chips{font-weight:700;color:var(--ok)}
    .folded{opacity:.55;filter:grayscale(.2)}
    .acting{outline:2px solid var(--warn)}

    /* 8 åº§ä½å¸ƒå±€ */
    .pos-top    {left:50%; top:3%;   transform:translate(-50%,0);}
    .pos-tr     {left:78%; top:12%;  transform:translate(-50%,0);}
    .pos-right  {left:94%; top:50%;  transform:translate(-50%,-50%);}
    .pos-br     {left:78%; top:86%;  transform:translate(-50%,-50%);}
    .pos-bottom {left:50%; top:97%;  transform:translate(-50%,-100%);}
    .pos-bl     {left:22%; top:86%;  transform:translate(-50%,-50%);}
    .pos-left   {left:6%;  top:50%;  transform:translate(-50%,-50%);}
    .pos-tl     {left:22%; top:12%;  transform:translate(-50%,0);}

    .cards{display:flex;gap:4px;margin:4px 0 2px}
    .card{
      width:34px;height:48px;border-radius:6px;border:1px solid #374151;display:grid;place-items:center;
      background:#0b1328;font-weight:700;font-size:11px
    }
    .card.face{background:#f8fafc;color:#0b1020;border-color:#cbd5e1}
    .card small{font-size:9px}
    .suit-red{color:#ef4444}

    .actions{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
    button{
      padding:6px 10px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:12px
    }
    button.primary{background:#1d4ed8;border-color:#1e40af}
    button.danger{background:#991b1b;border-color:#7f1d1d}
    button:disabled{opacity:.5;cursor:not-allowed}

    .drawer{
      position:fixed;right:0;top:0;height:100vh;width:320px;max-width:90vw;
      background:var(--panel);border-left:1px solid var(--border);box-shadow:-10px 0 24px rgba(0,0,0,.35);
      transform:translateX(100%);transition:transform .25s ease;z-index:50;padding:12px;display:grid;gap:10px
    }
    .drawer.open{transform:translateX(0)}
    .panel{border:1px solid var(--border);border-radius:10px;background:#132033;padding:10px}
    .panel h4{margin:.2em 0 .6em;font-size:13px}
    .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #223049;padding:4px 0;font-size:12px}
    .log{height:260px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:#0f172a;padding:8px;font-size:12px;line-height:1.5}
    .log p{margin:.2em 0;color:#c0cad6}

    @media (max-width:980px){
      .wrap{max-width:100%;padding:6px}
      .table{height:480px}
      .seat{width:138px}
      .card{width:32px;height:46px}
    }
    @media (max-width:720px){
      .seat{width:130px}
      .card{width:30px;height:44px;font-size:10px}
      .card small{font-size:8px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <button id="btnMenu" class="btn">èœå•</button>
      <span class="badge">åº•æ³¨: <b id="ante">10</b></span>
      <span class="badge">æœ¬è½®ç›²: <b id="roundBase">10</b></span>
      <span class="badge">ç›²ä¸Šé™: <b id="maxBase">20</b>ï¼ˆçœ‹ç‰Œ=Ã—2ï¼‰</span>
      <span class="badge">é—·æ³¨ä¸Šé™(è½®): <b id="maxRounds">30</b></span>
      <span class="badge">è½®åˆ°: <span id="turnName" class="turn">-</span></span>
      <span class="badge ghost">å½“å‰è½®: <b id="roundNow">1</b></span>
    </div>

    <div class="table">
      <div class="seats" id="seats"></div>
      <div class="center-pot">åº•æ± ï¼ˆPotï¼‰ï¼š<span class="pot" id="pot">0</span></div>
    </div>
  </div>

  <!-- ä¾§æ æŠ½å±‰ -->
  <aside class="drawer" id="drawer">
    <div class="panel">
      <h4>å±€é¢</h4>
      <div class="kv"><span>åº•æ± </span><b id="statPot">0</b></div>
      <div class="kv"><span>æœ¬è½®ç›²</span><b id="statRoundBase">10</b></div>
      <div class="kv"><span>å½“å‰è½®</span><b id="statRound">1</b></div>
      <div class="kv"><span>å­˜æ´»ç©å®¶</span><b id="statAlive">8</b></div>
    </div>
    <div class="panel">
      <h4>ä½ ï¼ˆç©å®¶ï¼‰</h4>
      <div class="kv"><span>ç­¹ç </span><b id="meChips">0</b></div>
      <div class="kv"><span>ä½ æœ¬è½®å·²ä¸‹</span><b id="meBet">0</b></div>
      <div class="kv"><span>çŠ¶æ€</span><b id="meState">é—·</b></div>
    </div>
    <div class="panel">
      <h4>æ—¥å¿—</h4>
      <div class="log" id="log"></div>
    </div>
    <button id="btnClose" class="btn">å…³é—­</button>
  </aside>

  <script>
    /* ---------- å·¥å…· & ç‰Œé¢ ---------- */
    const SUITS=['â™ ','â™¥','â™¦','â™£'], RANKS=[2,3,4,5,6,7,8,9,10,11,12,13,14];
    const RANK_LABEL=v=>({11:'J',12:'Q',13:'K',14:'A'}[v]||String(v)), isRed=s=>(s==='â™¥'||s==='â™¦');
    const createDeck=()=>{const d=[];for(const s of SUITS)for(const r of RANKS)d.push({suit:s,rank:r});return d;};
    const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]];}return a;};

    function evaluate3(hand){
      const ranks=hand.map(c=>c.rank).sort((a,b)=>b-a), suits=hand.map(c=>c.suit);
      const isFlush=(new Set(suits)).size===1;
      function straightHigh(rs){
        const r=[...new Set(rs)].sort((a,b)=>a-b); if(r.length!==3)return null;
        if(r[1]===r[0]+1&&r[2]===r[1]+1) return r[2];
        const r2=r.map(x=>x===14?1:x).sort((a,b)=>a-b);
        if(r2[1]===r2[0]+1&&r2[2]===r2[1]+1) return r2[2];
        return null;
      }
      const sh=straightHigh(ranks), counts={}; for(const r of ranks) counts[r]=(counts[r]||0)+1;
      const groups=Object.entries(counts).map(([r,c])=>({r:+r,c}));
      if(groups.some(g=>g.c===3)) return{cat:6,scoreVec:[groups.find(g=>g.c===3).r],name:'è±¹å­(ä¸‰æ¡)'};
      if(isFlush&&sh!==null) return{cat:5,scoreVec:[sh],name:'åŒèŠ±é¡º'};
      if(isFlush) return{cat:4,scoreVec:ranks,name:'åŒèŠ±'};
      if(sh!==null) return{cat:3,scoreVec:[sh],name:'é¡ºå­'};
      if(groups.some(g=>g.c===2)){const pair=groups.find(g=>g.c===2).r;const kick=groups.find(g=>g.c===1).r;return{cat:2,scoreVec:[pair,kick],name:'å¯¹å­'};}
      return{cat:1,scoreVec:ranks,name:'é«˜ç‰Œ'};
    }
    const compareHands=(a,b)=> a.cat!==b.cat ? a.cat-b.cat :
      (()=>{for(let i=0;i<Math.max(a.scoreVec.length,b.scoreVec.length);i++){const av=a.scoreVec[i]??0,bv=b.scoreVec[i]??0;if(av!==bv)return av-bv;}return 0;})();

    /* ---------- é…ç½® & çŠ¶æ€ ---------- */
    const cfg = { ante:10, startBase:10, maxBase:20, maxRounds:30, startChips:1000 };
    const state = {
      players: [], deck: [], pot: 0,
      roundIndex: 1, roundBase: cfg.startBase,
      turnIndex: 0, inHand: false, showdown: false
    };

    /* ---------- DOM & æŠ½å±‰ ---------- */
    const seatsEl=document.getElementById('seats'), logEl=document.getElementById('log');
    const potEl=document.getElementById('pot'), roundBaseEl=document.getElementById('roundBase'), maxBaseEl=document.getElementById('maxBase');
    const turnEl=document.getElementById('turnName'), roundNowEl=document.getElementById('roundNow');
    const statPotEl=document.getElementById('statPot'), statRoundBaseEl=document.getElementById('statRoundBase');
    const statAliveEl=document.getElementById('statAlive'), statRoundEl=document.getElementById('statRound');
    const meChipsEl=document.getElementById('meChips'), meBetEl=document.getElementById('meBet'), meStateEl=document.getElementById('meState');
    const drawer=document.getElementById('drawer');
    document.getElementById('btnMenu').onclick=()=>drawer.classList.add('open');
    document.getElementById('btnClose').onclick=()=>drawer.classList.remove('open');
    function log(msg){const p=document.createElement('p');p.textContent=msg;logEl.appendChild(p);logEl.scrollTop=logEl.scrollHeight;}

    /* ---------- åˆå§‹åŒ– ---------- */
    function setupPlayers(){
      state.players=[
        {id:0,name:'æœºå™¨äººA',pos:'pos-top',   isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:1,name:'æœºå™¨äººB',pos:'pos-tr',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:2,name:'æœºå™¨äººC',pos:'pos-right', isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:3,name:'æœºå™¨äººD',pos:'pos-br',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:4,name:'ä½ (ç©å®¶)',pos:'pos-bottom',isHuman:true,  chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:5,name:'æœºå™¨äººE',pos:'pos-bl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:6,name:'æœºå™¨äººF',pos:'pos-left',  isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:7,name:'æœºå™¨äººG',pos:'pos-tl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
      ];
    }
    const alivePlayers=()=>state.players.filter(p=>!p.folded && p.chips>=0);

    function newHand(){
      state.inHand=true; state.showdown=false; state.pot=0;
      state.roundIndex=1; state.roundBase=cfg.startBase; state.turnIndex=0;
      state.deck=shuffle(createDeck());
      for(const p of state.players){ p.hand=[state.deck.pop(),state.deck.pop(),state.deck.pop()]; p.folded=false; p.seen=false; p.betThisRound=0; }
      for(const p of alivePlayers()){ const ante=Math.min(cfg.ante,p.chips); p.chips-=ante; state.pot+=ante; }
      log('â€”â€” æ–°ä¸€å±€å¼€å§‹ï¼ˆé»˜è®¤é—·ï¼‰ï¼Œæ”¶å–ç›²åº•æ³¨ â€”â€”');
      render(); maybeAutoTurn();
    }

    /* ---------- ç›®æ ‡ä¸éœ€æ±‚ï¼šçœ‹ç‰Œ=ç›²Ã—2 ---------- */
    const targetFor = p => state.roundBase * (p.seen ? 2 : 1);
    const needFor   = p => Math.max(0, targetFor(p) - p.betThisRound);

    /* ---------- æ¸²æŸ“ï¼ˆæœºå™¨äººçœ‹ç‰Œä¹Ÿä¸äº®ç‰Œï¼‰ ---------- */
    function seatHtml(p,acting){
      const canSeeCards = p.isHuman ? (p.seen || state.showdown || p.folded) : (state.showdown || p.folded);
      const cards=p.hand.map(c=> canSeeCards
        ? `<div class="card face ${isRed(c.suit)?'suit-red':''}">${RANK_LABEL(c.rank)}<small>${c.suit}</small></div>`
        : `<div class="card">ğŸ‚ </div>`).join('');
      const stateTag = p.seen ? 'çœ‹' : 'é—·';
      return `
        <div class="seat ${p.pos} ${p.folded?'folded':''} ${acting?'acting':''}">
          <h3>${p.name} <span class="chips">ï¿¥${p.chips}</span> <span style="margin-left:auto;font-size:11px;color:#9fb0c1">[${stateTag}]</span> ${acting?'<span class="turn">ï¼ˆè¡ŒåŠ¨ï¼‰</span>':''}</h3>
          <div class="cards">${cards}</div>
          <div style="font-size:11px;color:#9fb0c1;display:flex;gap:8px">
            <span>å·²ä¸‹ï¼šï¿¥${p.betThisRound}</span><span>éœ€è‡³ï¼šï¿¥${targetFor(p)}</span>
          </div>
          ${p.isHuman?humanActionsHtml():''}
        </div>`;
    }
    function humanActionsHtml(){
      return `<div class="actions" id="actionBar">
        <button id="btnSee">çœ‹ç‰Œ</button>
        <button id="btnFold" class="danger">å¼ƒç‰Œ</button>
        <button id="btnCall">è·Ÿæ³¨</button>
        <button id="btnRaise" class="primary">åŠ æ³¨(ç›²Ã—2)</button>
        <button id="btnShowdown" title="ä»…å‰©ä¸€åå¯¹æ‰‹æ—¶å¯å¼€ç‰Œ">å¼€ç‰Œ</button>
        <button id="btnNext" style="display:none;">ä¸‹ä¸€å±€</button>
      </div>`;
    }

    function render(){
      potEl.textContent=state.pot;
      roundBaseEl.textContent=state.roundBase;
      maxBaseEl.textContent=cfg.maxBase;
      turnEl.textContent=state.inHand?state.players[state.turnIndex].name:'-';
      statPotEl.textContent=state.pot;
      statRoundBaseEl.textContent=state.roundBase;
      statRoundEl.textContent=state.roundIndex;
      const alive=alivePlayers();
      statAliveEl.textContent=alive.length;
      roundNowEl.textContent=state.roundIndex;

      const me=state.players[4];
      meChipsEl.textContent=me.chips;
      meBetEl.textContent=me.betThisRound;
      meStateEl.textContent=me.seen?'çœ‹':'é—·';

      seatsEl.innerHTML='';
      state.players.forEach((p,i)=>seatsEl.insertAdjacentHTML('beforeend',seatHtml(p, state.inHand && i===state.turnIndex && !state.showdown && !p.folded)));

      const myTurn = state.inHand && !state.showdown && !me.folded && state.turnIndex===4;
      const btnSee=document.getElementById('btnSee'),
            btnFold=document.getElementById('btnFold'),
            btnCall=document.getElementById('btnCall'),
            btnRaise=document.getElementById('btnRaise'),
            btnShow=document.getElementById('btnShowdown'),
            btnNext=document.getElementById('btnNext');

      if(btnSee){ btnSee.disabled=!(myTurn && !me.seen); btnSee.onclick=()=>playerSee(); }
      if(btnFold){ btnFold.disabled=!myTurn; btnFold.onclick=()=>playerFold(); }
      if(btnCall){ btnCall.disabled=!myTurn; btnCall.onclick=()=>playerCall(); }
      if(btnRaise){ btnRaise.disabled=!(myTurn && state.roundBase < cfg.maxBase); btnRaise.onclick=()=>playerRaise(); }
      if(btnShow){ btnShow.disabled=!(state.inHand && !state.showdown && alive.length===2 && myTurn); btnShow.onclick=()=>showdown('ç©å®¶å¼€ç‰Œ'); }
      if(btnNext){ btnNext.style.display=(!state.inHand && state.showdown)?'inline-block':'none'; btnNext.onclick=()=>newHand(); }
    }

    /* ---------- è¡ŒåŠ¨ ---------- */
    const payToPot=(p,amount)=>{const pay=Math.max(0,Math.min(amount,p.chips));p.chips-=pay;p.betThisRound+=pay;state.pot+=pay;return pay;};

    function playerSee(){ const me=state.players[4]; if(me.seen) return; me.seen=true; log('ä½ é€‰æ‹©ï¼šçœ‹ç‰Œï¼ˆä¹‹åä½ çš„è·Ÿæ³¨=ç›²Ã—2ï¼‰'); render(); }
    function playerFold(){ const me=state.players[4]; me.folded=true; log('ä½ é€‰æ‹©ï¼šå¼ƒç‰Œ'); advanceTurn(); }
    function playerCall(){ const me=state.players[4]; const need=needFor(me); const paid=payToPot(me,need); log(`ä½ ï¼šè·Ÿæ³¨ ï¿¥${paid}ï¼ˆç›²=${state.roundBase}ï¼Œä½ çš„ç›®æ ‡=${targetFor(me)}ï¼‰`); advanceTurn(); }
    function playerRaise(){
      const me=state.players[4];
      if(state.roundBase>=cfg.maxBase){ return playerCall(); }
      const needCall = needFor(me);
      const paidCall = payToPot(me, needCall);
      state.roundBase = Math.min(state.roundBase*2, cfg.maxBase);
      log(`ä½ ï¼šå…ˆè¡¥ ï¿¥${paidCall}ï¼ŒæŠŠç›²æå‡è‡³ ï¿¥${state.roundBase}${me.seen?'ï¼ˆä½ çœ‹ç‰Œï¼Œç›®æ ‡=ç›²Ã—2ï¼‰':''}`);
      const needAfter = needFor(me);
      if(needAfter>0){ const paidRaise = payToPot(me, needAfter); log(`ä½ ï¼šä¸ºæ»¡è¶³æ–°ç›®æ ‡å†è¡¥ ï¿¥${paidRaise}ï¼ˆæ–°ç›®æ ‡=${targetFor(me)}ï¼‰`); }
      advanceTurn();
    }

    /* ---------- å›åˆæ¨è¿› & é—·æ³¨ä¸Šé™ ---------- */
    const allMatched=()=>alivePlayers().every(p=>p.betThisRound===targetFor(p));

    function advanceTurn(){
      const alive=alivePlayers();
      if(alive.length===1) return winByFold(alive[0]);

      if(allMatched()){
        if(state.roundIndex >= cfg.maxRounds){ return showdown('è¾¾åˆ°é—·æ³¨ä¸Šé™ï¼Œå¼ºåˆ¶å¼€ç‰Œ'); }
        state.roundIndex += 1;
        state.roundBase = cfg.startBase;
        for(const p of alive) p.betThisRound = 0;
        log(`â€”â€” è¿›å…¥ç¬¬ ${state.roundIndex} è½®ï¼ˆç›²é‡ç½® ï¿¥${state.roundBase}ï¼›çœ‹ç‰Œè€…ç›®æ ‡=ï¿¥${state.roundBase*2}ï¼‰â€”â€”`);
      }

      const n=state.players.length;
      for(let step=1; step<=n; step++){
        const idx=(state.turnIndex+step)%n; const cand=state.players[idx];
        if(!cand.folded){ state.turnIndex=idx; break; }
      }
      render(); maybeAutoTurn();
    }

    /* ---------- æœºå™¨äººé€»è¾‘ ---------- */
    function botStrength(p){
      if(!p.seen){ return 200 + Math.random()*100; } // æœªçœ‹ç‰Œï¼šå¼±ä¿¡æ¯ï¼Œé¼“åŠ±é—·å’Œå°è·Ÿ
      const eva=evaluate3(p.hand); let minor=0; if(eva.scoreVec?.length) minor=eva.scoreVec.reduce((acc,v,i)=>acc+v*Math.pow(0.01,i),0);
      return eva.cat*100+minor;
    }
    function botMaybeSee(p){
      if(p.seen||p.folded) return;
      const need=needFor(p);
      const pressure = need / 20;
      const baseProb = Math.min(0.08 + 0.03*(state.roundIndex-1) + 0.10*pressure, 0.55);
      if(Math.random()<baseProb){ p.seen=true; log(`${p.name}ï¼šçœ‹ç‰Œ`); }
    }
    function botAct(p){
      if(!state.inHand||state.showdown||p.folded) return;
      const alive = alivePlayers();
      const canShow = alive.length===2;

      botMaybeSee(p);

      const need=needFor(p);
      const S=botStrength(p);
      const STRONG=520, MEDIUM=260;

      const canRaiseBase = state.roundBase < cfg.maxBase;
      if(S>=STRONG && canRaiseBase){
        payToPot(p, need);
        state.roundBase = cfg.maxBase;
        log(`${p.name}ï¼šæå‡ç›²è‡³ ï¿¥${state.roundBase}${p.seen?'ï¼ˆå…¶ç›®æ ‡=ï¿¥40ï¼‰':'ï¼ˆå…¶ç›®æ ‡=ï¿¥20ï¼‰'}`);
        const needAfter = needFor(p);
        if(needAfter>0){ payToPot(p, needAfter); }
        return advanceTurn();
      }

      if(S>=MEDIUM || need===0){
        const paid=payToPot(p,need); log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
      }else{
        if(need>0 && Math.random()<0.40){ p.folded=true; log(`${p.name}ï¼šå¼ƒç‰Œ`); }
        else{ const paid=payToPot(p,need); log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`); }
      }

      if(canShow && S>=STRONG && Math.random()<0.25){
        return showdown(`${p.name} å‘èµ·å¼€ç‰Œ`);
      }
      advanceTurn();
    }
    const maybeAutoTurn=()=>{ const p=state.players[state.turnIndex]; if(p && !p.isHuman) setTimeout(()=>botAct(p),560); };

    /* ---------- æ‘Šç‰Œ & ç»“æœ ---------- */
    function showdown(reason='å¼€ç‰Œ'){
      if(!state.inHand||state.showdown) return;
      state.inHand=false; state.showdown=true; log(`ã€${reason}ã€‘è¿›å…¥æ‘Šç‰Œ`);
      const alive=alivePlayers(); let best=null, winners=[];
      for(const p of alive){ const eva=evaluate3(p.hand);
        if(!best){best={p,eva};winners=[p];}
        else{ const cmp=compareHands(eva,best.eva); if(cmp>0){best={p,eva};winners=[p];} else if(cmp===0){winners.push(p);} }
      }
      if(winners.length===1){ winners[0].chips+=state.pot; log(`èµ¢å®¶ï¼š${winners[0].name}ï¼ˆ${evaluate3(winners[0].hand).name}ï¼‰ï¼Œèµ¢å¾— ï¿¥${state.pot}`); }
      else{ const share=Math.floor(state.pot/winners.length); for(const w of winners) w.chips+=share; log(`å¹³åˆ†åº•æ± ï¼š${winners.map(w=>w.name).join('ã€')} å„å¾— ï¿¥${share}`); }
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }
    function winByFold(p){
      state.inHand=false; state.showdown=true; p.chips+=state.pot; log(`å…¶ä½™ç©å®¶å¼ƒç‰Œï¼Œ${p.name} ç›´æ¥èµ¢å¾— ï¿¥${state.pot}`);
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }

    /* ---------- å¯åŠ¨ ---------- */
    document.getElementById('ante').textContent=cfg.ante;
    document.getElementById('maxBase').textContent=cfg.maxBase;
    document.getElementById('maxRounds').textContent=cfg.maxRounds;

    setupPlayers();
    newHand();
  </script>
</body>
</html>
