<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>æ‰é‡‘èŠ± Â· å…«åº§ä½ï¼ˆé—·/çœ‹ç‰ŒåŒå€æ³¨ç‰ˆï¼‰</title>

  <!-- å¯é€‰ï¼šPWAï¼ˆè‹¥æ²¡æœ‰å¯å…ˆæ³¨é‡Šï¼‰ -->
  <link rel="manifest" href="./manifest.json" />
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js', { scope: './' }).catch(console.error);
      });
    }
  </script>

  <style>
    :root{
      --bg:#0b1020; --felt:#0d1b2a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb;
      --accent:#22d3ee; --danger:#f43f5e; --ok:#10b981; --warn:#f59e0b; --border:#293241;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:10px;display:grid;gap:10px}

    .topbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{padding:3px 8px;border:1px solid var(--border);border-radius:10px;background:#0f172a;font-size:13px}
    .pot{font-weight:700;color:var(--accent)}
    .turn{color:var(--warn);font-weight:700}

    .table{
      position:relative;height:580px;border:1px solid var(--border);border-radius:16px;
      background: radial-gradient(ellipse at center,#0f2a2a 0%, var(--felt) 60%, #0b1328 100%);
      overflow:hidden;
    }
    .seats{position:absolute; inset:0;}
    .center-pot{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(15,23,42,.8); border:1px solid var(--border); border-radius:12px;
      padding:6px 12px; font-size:14px; color:#e5e7eb; box-shadow:0 6px 16px rgba(0,0,0,.25);
    }

    .seat{
      position:absolute;width:170px;max-width:30vw;border:1px solid var(--border);
      border-radius:10px;background:var(--panel);padding:6px;box-shadow:0 6px 16px rgba(0,0,0,.2)
    }
    .seat h3{margin:0 0 4px;font-size:14px;display:flex;align-items:center;gap:6px}
    .chips{font-weight:700;color:var(--ok)}
    .folded{opacity:.55;filter:grayscale(.2)}
    .acting{outline:2px solid var(--warn)}

    .pos-top    {left:50%; top:4%;   transform:translate(-50%,0);}
    .pos-tr     {left:79%; top:15%;  transform:translate(-50%,0);}
    .pos-right  {left:92%; top:50%;  transform:translate(-50%,-50%);}
    .pos-br     {left:79%; top:82%;  transform:translate(-50%,-50%);}
    .pos-bottom {left:50%; top:96%;  transform:translate(-50%,-100%);}
    .pos-bl     {left:21%; top:82%;  transform:translate(-50%,-50%);}
    .pos-left   {left:8%;  top:50%;  transform:translate(-50%,-50%);}
    .pos-tl     {left:21%; top:15%;  transform:translate(-50%,0);}

    .cards{display:flex;gap:6px;margin:4px 0 2px}
    .card{
      width:40px;height:58px;border-radius:8px;border:1px solid #374151;display:grid;place-items:center;
      background:#0b1328;font-weight:700;font-size:13px
    }
    .card.face{background:#f8fafc;color:#0b1020;border-color:#cbd5e1}
    .card small{font-size:10px}
    .suit-red{color:#ef4444}

    .actions{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
    button{
      padding:6px 10px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:13px
    }
    button.primary{background:#1d4ed8;border-color:#1e40af}
    button.danger{background:#991b1b;border-color:#7f1d1d}
    button:disabled{opacity:.5;cursor:not-allowed}

    .sidebar{display:grid;gap:10px}
    .panel{border:1px solid var(--border);border-radius:10px;background:var(--panel);padding:10px}
    .panel h4{margin:.2em 0 .6em;font-size:14px}
    .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #223049;padding:4px 0;font-size:13px}
    .log{height:160px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:#0f172a;padding:8px;font-size:12px;line-height:1.5}
    .log p{margin:.2em 0;color:#c0cad6}

    @media (max-width:980px){
      .wrap{max-width:100%;padding:8px}
      .table{height:540px}
      .seat{width:160px}
      .card{width:36px;height:54px}
    }
    @media (max-width:720px){
      .seat{width:150px}
      .card{width:34px;height:52px;font-size:12px}
      .card small{font-size:9px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <span class="badge">åº•æ³¨: <b id="ante">10</b></span>
      <span class="badge">æœ¬è½®åº•æ³¨(ç›²): <b id="roundBase">10</b></span>
      <span class="badge">åº•æ³¨ä¸Šé™(ç›²): <b id="maxBase">20</b>ï¼ˆçœ‹ç‰Œ=Ã—2ï¼‰</span>
      <span class="badge">é—·æ³¨ä¸Šé™(è½®): <b id="maxRounds">30</b></span>
      <span class="badge">è½®åˆ°: <span id="turnName" class="turn">-</span></span>
      <span class="badge">å½“å‰è½®æ¬¡: <b id="roundNow">1</b></span>
    </div>

    <div class="table">
      <div class="seats" id="seats"></div>
      <div class="center-pot">åº•æ± ï¼ˆPotï¼‰ï¼š<span class="pot" id="pot">0</span></div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <h4>å±€é¢</h4>
        <div class="kv"><span>åº•æ± </span><b id="statPot">0</b></div>
        <div class="kv"><span>æœ¬è½®åº•æ³¨(ç›²)</span><b id="statRoundBase">10</b></div>
        <div class="kv"><span>å½“å‰è½®æ¬¡</span><b id="statRound">1</b></div>
        <div class="kv"><span>å­˜æ´»ç©å®¶</span><b id="statAlive">8</b></div>
      </div>
      <div class="panel">
        <h4>ä½ ï¼ˆç©å®¶ï¼‰</h4>
        <div class="kv"><span>ç­¹ç </span><b id="meChips">0</b></div>
        <div class="kv"><span>ä½ æœ¬è½®å·²ä¸‹</span><b id="meBet">0</b></div>
        <div class="kv"><span>çŠ¶æ€</span><b id="meState">é—·</b></div>
      </div>
      <div class="panel">
        <h4>æ—¥å¿—</h4>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <script>
    /* ---------- å·¥å…· & ç‰Œé¢ ---------- */
    const SUITS=['â™ ','â™¥','â™¦','â™£'], RANKS=[2,3,4,5,6,7,8,9,10,11,12,13,14];
    const RANK_LABEL=v=>({11:'J',12:'Q',13:'K',14:'A'}[v]||String(v)), isRed=s=>(s==='â™¥'||s==='â™¦');
    const createDeck=()=>{const d=[];for(const s of SUITS)for(const r of RANKS)d.push({suit:s,rank:r});return d;};
    const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]];}return a;};

    function evaluate3(hand){
      const ranks=hand.map(c=>c.rank).sort((a,b)=>b-a), suits=hand.map(c=>c.suit);
      const isFlush=(new Set(suits)).size===1;
      function straightHigh(rs){
        const r=[...new Set(rs)].sort((a,b)=>a-b); if(r.length!==3)return null;
        if(r[1]===r[0]+1&&r[2]===r[1]+1) return r[2];
        const r2=r.map(x=>x===14?1:x).sort((a,b)=>a-b);
        if(r2[1]===r2[0]+1&&r2[2]===r2[1]+1) return r2[2];
        return null;
      }
      const sh=straightHigh(ranks), counts={}; for(const r of ranks) counts[r]=(counts[r]||0)+1;
      const groups=Object.entries(counts).map(([r,c])=>({r:+r,c}));
      if(groups.some(g=>g.c===3)){const v=groups.find(g=>g.c===3).r;return{cat:6,scoreVec:[v],name:'è±¹å­(ä¸‰æ¡)'};}
      if(isFlush&&sh!==null) return{cat:5,scoreVec:[sh],name:'åŒèŠ±é¡º'};
      if(isFlush) return{cat:4,scoreVec:ranks,name:'åŒèŠ±'};
      if(sh!==null) return{cat:3,scoreVec:[sh],name:'é¡ºå­'};
      if(groups.some(g=>g.c===2)){const pair=groups.find(g=>g.c===2).r;const kick=groups.find(g=>g.c===1).r;return{cat:2,scoreVec:[pair,kick],name:'å¯¹å­'};}
      return{cat:1,scoreVec:ranks,name:'é«˜ç‰Œ'};
    }
    const compareHands=(a,b)=> a.cat!==b.cat ? a.cat-b.cat :
      (()=>{for(let i=0;i<Math.max(a.scoreVec.length,b.scoreVec.length);i++){const av=a.scoreVec[i]??0,bv=b.scoreVec[i]??0; if(av!==bv) return av-bv;} return 0;})();

    /* ---------- é…ç½® & çŠ¶æ€ï¼ˆé—·/çœ‹ç‰Œ åŒå€æ³¨ï¼‰ ---------- */
    const cfg = {
      ante: 10,
      startBase: 10,       // â€œç›²åº•æ³¨â€èµ·ç‚¹
      maxBase: 20,         // ç›²åº•æ³¨ä¸Šé™ï¼ˆçœ‹ç‰Œéœ€æ±‚=ç›²Ã—2ï¼Œæ•…æ€»ä¸Šé™=40ï¼‰
      maxRounds: 30,       // é—·æ³¨ä¸Šé™ï¼ˆè½®ï¼‰
      startChips: 1000
    };
    const state = {
      players: [], // {id,name,pos,isHuman,chips,hand,folded,seen,betThisRound}
      deck: [],
      pot: 0,
      roundIndex: 1,
      roundBase: cfg.startBase, // å½“è½®ç›²åº•æ³¨ï¼ˆçœ‹ç‰Œ=Ã—2ï¼‰
      turnIndex: 0,
      inHand: false,
      showdown: false
    };

    /* ---------- DOM ---------- */
    const seatsEl=document.getElementById('seats'), logEl=document.getElementById('log');
    const potEl=document.getElementById('pot'), roundBaseEl=document.getElementById('roundBase'), maxBaseEl=document.getElementById('maxBase');
    const turnEl=document.getElementById('turnName'), roundNowEl=document.getElementById('roundNow');
    const statPotEl=document.getElementById('statPot'), statRoundBaseEl=document.getElementById('statRoundBase');
    const statAliveEl=document.getElementById('statAlive'), statRoundEl=document.getElementById('statRound');
    const meChipsEl=document.getElementById('meChips'), meBetEl=document.getElementById('meBet'), meStateEl=document.getElementById('meState');

    function log(msg){const p=document.createElement('p');p.textContent=msg;logEl.appendChild(p);logEl.scrollTop=logEl.scrollHeight;}

    /* ---------- åˆå§‹åŒ– ---------- */
    function setupPlayers(){
      state.players=[
        {id:0,name:'æœºå™¨äººA',pos:'pos-top',   isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:1,name:'æœºå™¨äººB',pos:'pos-tr',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:2,name:'æœºå™¨äººC',pos:'pos-right', isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:3,name:'æœºå™¨äººD',pos:'pos-br',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:4,name:'ä½ (ç©å®¶)',pos:'pos-bottom',isHuman:true, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:5,name:'æœºå™¨äººE',pos:'pos-bl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:6,name:'æœºå™¨äººF',pos:'pos-left',  isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:7,name:'æœºå™¨äººG',pos:'pos-tl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
      ];
    }

    function newHand(){
      state.inHand=true; state.showdown=false; state.pot=0;
      state.roundIndex=1; state.roundBase=cfg.startBase; state.turnIndex=0;
      state.deck=shuffle(createDeck());
      for(const p of state.players){ p.hand=[state.deck.pop(),state.deck.pop(),state.deck.pop()]; p.folded=false; p.seen=false; p.betThisRound=0; }
      // æ”¶å–åº•æ³¨ï¼ˆç›²ï¼‰
      for(const p of alivePlayers()){ const ante=Math.min(cfg.ante,p.chips); p.chips-=ante; state.pot+=ante; }
      log('â€”â€” æ–°ä¸€å±€å¼€å§‹ï¼ˆé»˜è®¤é—·ï¼‰ï¼Œæ”¶å–ç›²åº•æ³¨ â€”â€”');
      render(); maybeAutoTurn();
    }
    const alivePlayers=()=>state.players.filter(p=>!p.folded && p.chips>=0);

    /* ---------- éœ€æ±‚è®¡ç®—ï¼šçœ‹ç‰Œ=åº•æ³¨Ã—2 ---------- */
    function targetFor(p){ return state.roundBase * (p.seen ? 2 : 1); }
    function needFor(p){ return Math.max(0, targetFor(p) - p.betThisRound); }

    /* ---------- æ¸²æŸ“ ---------- */
    function seatHtml(p,acting){
      const faceUp=p.seen||state.showdown||p.folded;
      const cards=p.hand.map(c=> faceUp
        ? `<div class="card face ${isRed(c.suit)?'suit-red':''}">${RANK_LABEL(c.rank)}<small>${c.suit}</small></div>`
        : `<div class="card">ğŸ‚ </div>`).join('');
      const stateTag = p.seen ? 'çœ‹' : 'é—·';
      return `
        <div class="seat ${p.pos} ${p.folded?'folded':''} ${acting?'acting':''}">
          <h3>${p.name} <span class="chips">ï¿¥${p.chips}</span> <span style="margin-left:auto;font-size:12px;color:#9fb0c1">[${stateTag}]</span> ${acting?'<span class="turn">ï¼ˆè¡ŒåŠ¨ï¼‰</span>':''}</h3>
          <div class="cards">${cards}</div>
          <div style="font-size:12px;color:#9fb0c1;display:flex;gap:8px">
            <span>å·²ä¸‹ï¼šï¿¥${p.betThisRound}</span><span>éœ€è‡³ï¼šï¿¥${targetFor(p)}</span>
          </div>
          ${p.isHuman?humanActionsHtml():''}
        </div>`;
    }
    function humanActionsHtml(){
      return `<div class="actions" id="actionBar">
        <button id="btnSee">çœ‹ç‰Œ</button>
        <button id="btnFold" class="danger">å¼ƒç‰Œ</button>
        <button id="btnCall">è·Ÿæ³¨</button>
        <button id="btnRaise" class="primary">åŠ æ³¨(Ã—2ç›²)</button>
        <button id="btnShowdown" title="åªå‰©ä¸€åå¯¹æ‰‹æ—¶å¯å¼€ç‰Œ">å¼€ç‰Œ</button>
        <button id="btnNext" style="display:none;">ä¸‹ä¸€å±€</button>
      </div>`;
    }

    function render(){
      potEl.textContent=state.pot;
      roundBaseEl.textContent=state.roundBase;
      maxBaseEl.textContent=cfg.maxBase;
      turnEl.textContent=state.inHand?state.players[state.turnIndex].name:'-';
      statPotEl.textContent=state.pot;
      statRoundBaseEl.textContent=state.roundBase;
      statRoundEl.textContent=state.roundIndex;
      const alive=alivePlayers();
      statAliveEl.textContent=alive.length;
      roundNowEl.textContent=state.roundIndex;

      const me=state.players[4];
      meChipsEl.textContent=me.chips;
      meBetEl.textContent=me.betThisRound;
      meStateEl.textContent=me.seen?'çœ‹':'é—·';

      seatsEl.innerHTML='';
      state.players.forEach((p,i)=>seatsEl.insertAdjacentHTML('beforeend',seatHtml(p, state.inHand && i===state.turnIndex && !state.showdown && !p.folded)));

      const myTurn = state.inHand && !state.showdown && !me.folded && state.turnIndex===4;
      const btnSee=document.getElementById('btnSee'),
            btnFold=document.getElementById('btnFold'),
            btnCall=document.getElementById('btnCall'),
            btnRaise=document.getElementById('btnRaise'),
            btnShow=document.getElementById('btnShowdown'),
            btnNext=document.getElementById('btnNext');

      if(btnSee){ btnSee.disabled=!(myTurn && !me.seen); btnSee.onclick=()=>playerSee(); }
      if(btnFold){ btnFold.disabled=!myTurn; btnFold.onclick=()=>playerFold(); }
      if(btnCall){ btnCall.disabled=!myTurn; btnCall.onclick=()=>playerCall(); }
      if(btnRaise){
        // åªèƒ½æŠŠç›²åº•æ³¨ä» 10 æåˆ° 20ï¼ˆçœ‹ç‰Œå³ç­‰ä»· 20->40ï¼‰ï¼Œè¶…è¿‡å°±ç¦ç”¨
        btnRaise.disabled=!(myTurn && state.roundBase < cfg.maxBase);
        btnRaise.onclick=()=>playerRaise();
      }
      if(btnShow){
        // åªèƒ½åœ¨â€œåªå‰©ä½ å’Œ 1 åå¯¹æ‰‹â€æ—¶å¼€ç‰Œ
        btnShow.disabled=!(state.inHand && !state.showdown && alive.length===2 && myTurn);
        btnShow.onclick=()=>showdown('ç©å®¶å¼€ç‰Œ');
      }
      if(btnNext){ btnNext.style.display=(!state.inHand && state.showdown)?'inline-block':'none'; btnNext.onclick=()=>newHand(); }
    }

    /* ---------- è¡ŒåŠ¨ ---------- */
    function payToPot(p,amount){
      const pay=Math.max(0,Math.min(amount,p.chips));
      p.chips-=pay; p.betThisRound+=pay; state.pot+=pay; return pay;
    }

    function playerSee(){
      const me=state.players[4];
      if(me.seen) return;
      me.seen=true;
      log('ä½ é€‰æ‹©ï¼šçœ‹ç‰Œï¼ˆä¹‹åä½ çš„è·Ÿæ³¨=ç›²Ã—2ï¼‰');
      render(); // ç«‹åˆ»åˆ·æ–°æ˜¾ç¤ºæ˜ç‰Œ
    }

    function playerFold(){ const me=state.players[4]; me.folded=true; log('ä½ é€‰æ‹©ï¼šå¼ƒç‰Œ'); advanceTurn(); }

    function playerCall(){
      const me=state.players[4];
      const need=needFor(me);
      const paid=payToPot(me,need);
      log(`ä½ é€‰æ‹©ï¼šè·Ÿæ³¨ï¼Œæ”¯ä»˜ ï¿¥${paid}ï¼ˆç›²=${state.roundBase}ï¼Œä½ çš„ç›®æ ‡=${targetFor(me)}ï¼‰`);
      advanceTurn();
    }

    function playerRaise(){
      const me=state.players[4];
      if(state.roundBase>=cfg.maxBase){ return playerCall(); }
      // â€œä¸»åŠ¨é—·20â€ï¼šå¦‚æœä½ æ˜¯é—·ä¸”æŠŠç›²ä»10æŠ¬åˆ°20ï¼Œåˆ™ä½ ç›®æ ‡ä»=ç›²(20)*1=20ï¼›è‹¥ä¹‹åå†çœ‹ç‰Œï¼Œä½ çš„ç›®æ ‡å°†å˜ä¸º40
      const needCall = needFor(me); // å…ˆè¡¥åˆ°å½“å‰è‡ªå·±çš„ç›®æ ‡ï¼ˆé¿å…æ¬ è´¦ï¼‰
      const paidCall = payToPot(me, needCall);
      const newBase = Math.min(state.roundBase*2, cfg.maxBase);
      state.roundBase = newBase;
      log(`ä½ ï¼šå…ˆè¡¥ ï¿¥${paidCall}ï¼ŒæŠŠç›²åº•æ³¨æå‡è‡³ ï¿¥${state.roundBase}${me.seen?'ï¼ˆä½ çœ‹ç‰Œï¼Œç›®æ ‡=ç›²Ã—2ï¼‰':''}`);
      // ç›²å˜åŒ–åï¼Œè‹¥ä½ çš„ betThisRound < æ–°ç›®æ ‡ï¼Œåˆ™å†è¡¥
      const needAfter = needFor(me);
      if(needAfter>0){
        const paidRaise = payToPot(me, needAfter);
        log(`ä½ ï¼šä¸ºæ»¡è¶³æ–°ç›®æ ‡å†è¡¥ ï¿¥${paidRaise}ï¼ˆä½ çš„æ–°ç›®æ ‡=${targetFor(me)}ï¼‰`);
      }
      advanceTurn();
    }

    /* ---------- å›åˆæ¨è¿› & é—·æ³¨ä¸Šé™ ---------- */
    function allMatched(){
      const alive=alivePlayers();
      return alive.every(p=>p.betThisRound === targetFor(p));
    }

    function advanceTurn(){
      const alive=alivePlayers();
      if(alive.length===1) return winByFold(alive[0]);

      // å½“æ‰€æœ‰æœªå¼ƒç‰Œè€…éƒ½è¡¥åˆ°å„è‡ªç›®æ ‡ â†’ è¿›å…¥ä¸‹ä¸€è½®ï¼ˆç›²æ¢å¤ä¸º 10ï¼›æ¯äººæœ¬è½®ä¸‹æ³¨æ¸…é›¶ï¼‰
      if(allMatched()){
        if(state.roundIndex >= cfg.maxRounds){
          return showdown('è¾¾åˆ°é—·æ³¨ä¸Šé™ï¼Œå¼ºåˆ¶å¼€ç‰Œ');
        }
        state.roundIndex += 1;
        state.roundBase = cfg.startBase;
        for(const p of alive) p.betThisRound = 0;
        log(`â€”â€” è¿›å…¥ç¬¬ ${state.roundIndex} è½®ï¼ˆç›²é‡ç½®ä¸º ï¿¥${state.roundBase}ï¼›çœ‹ç‰Œè€…ç›®æ ‡=ï¿¥${state.roundBase*2}ï¼‰â€”â€”`);
      }

      // é¡ºæ—¶é’ˆè‡³ä¸‹ä¸€ä½æœªå¼ƒç‰Œè€…
      const n=state.players.length;
      for(let step=1; step<=n; step++){
        const idx=(state.turnIndex+step)%n; const cand=state.players[idx];
        if(!cand.folded){ state.turnIndex=idx; break; }
      }
      render(); maybeAutoTurn();
    }

    /* ---------- æœºå™¨äººé€»è¾‘ï¼ˆé—·/çœ‹ç‰Œï¼‰ ---------- */
    function botStrength(p){
      if(!p.seen){
        // æœªçœ‹ç‰Œï¼šä¿¡æ¯ä¸è¶³ï¼Œç”¨æ¸©å’Œéšæœºå¼ºåº¦ï¼ˆé¼“åŠ±é—·æ³¨ä¸å°é¢è·Ÿæ³¨ï¼‰
        return 200 + Math.random()*100; // 200~300 ä¹‹é—´
      }
      const eva=evaluate3(p.hand); let minor=0; if(eva.scoreVec?.length) minor=eva.scoreVec.reduce((acc,v,i)=>acc+v*Math.pow(0.01,i),0);
      return eva.cat*100+minor; // çœ‹ç‰ŒåæŒ‰çœŸå®å¼ºåº¦
    }

    function botMaybeSee(p){
      if(p.seen||p.folded) return;
      // ç®€å•ç­–ç•¥ï¼šè½®æ•°å¢åŠ ã€æˆ–éœ€è¦è¡¥çš„é‡‘é¢è¾ƒå¤§æ—¶ï¼Œé€æ­¥æé«˜çœ‹ç‰Œæ¦‚ç‡
      const pressure = needFor(p) / 20; // 0~2 å·¦å³
      const baseProb = Math.min(0.10 + 0.03*(state.roundIndex-1) + 0.10*pressure, 0.6);
      if(Math.random()<baseProb){
        p.seen=true;
        log(`${p.name}ï¼šçœ‹ç‰Œ`);
      }
    }

    function botAct(p){
      if(!state.inHand||state.showdown||p.folded) return;

      // åªæœ‰å½“åœºä¸Šåªå‰©2äººæ—¶ï¼Œæœºå™¨äººæ‰ä¼šè€ƒè™‘â€œå¼€ç‰Œâ€
      const alive = alivePlayers();
      const canShow = alive.length===2;

      // å†³ç­–é¡ºåºï¼šæ˜¯å¦çœ‹ç‰Œ -> è·Ÿ/åŠ /å¼ƒ -> è‹¥åªå‰©äºŒäººï¼Œæ ¹æ®å¼ºåº¦å°‘é‡æ¦‚ç‡å¼€ç‰Œ
      botMaybeSee(p);

      const need=needFor(p);
      const S=botStrength(p);        // 200~300(é—·) / çœŸå¼ºåº¦(çœ‹)
      const STRONG=520, MEDIUM=260;  // çœ‹ç‰Œåå¼ºå¼±é˜ˆå€¼ï¼›é—·çŠ¶æ€ä¸‹é€šå¸¸è½åœ¨ MEDIUM é™„è¿‘

      // èƒ½å¦æŠŠç›²ä»10æŠ¬åˆ°20ï¼ˆæŠ¬ç›²åï¼Œçœ‹ç‰Œè€…ç›®æ ‡=40ï¼Œé—·è€…ç›®æ ‡=20ï¼‰
      const canRaiseBase = state.roundBase < cfg.maxBase;
      if(S>=STRONG && canRaiseBase){
        // å…ˆè¡¥åˆ°å½“å‰è‡ªå·±çš„ç›®æ ‡
        payToPot(p, need);
        // æŠ¬ç›²åˆ° 20
        state.roundBase = cfg.maxBase;
        log(`${p.name}ï¼šæŠŠç›²åº•æ³¨æå‡è‡³ ï¿¥${state.roundBase}${p.seen?'ï¼ˆå…¶ç›®æ ‡=ï¿¥40ï¼‰':'ï¼ˆå…¶ç›®æ ‡=ï¿¥20ï¼‰'}`);
        // è‹¥æŠ¬ç›²åè‡ªèº«æœªè¾¾æ–°ç›®æ ‡ï¼Œåˆ™ç»§ç»­è¡¥
        const needAfter = needFor(p);
        if(needAfter>0){ payToPot(p, needAfter); }
        return advanceTurn();
      }

      // ä¸€èˆ¬è·Ÿæ³¨/å¼ƒç‰Œ
      if(S>=MEDIUM || need===0){
        const paid=payToPot(p,need); log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
      }else{
        if(need>0 && Math.random()<0.40){ p.folded=true; log(`${p.name}ï¼šå¼ƒç‰Œ`); }
        else{ const paid=payToPot(p,need); log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`); }
      }

      // åªå‰©ä¸¤äººæ—¶ï¼Œå¼ºç‰Œå°æ¦‚ç‡ä¸»åŠ¨å¼€ç‰Œ
      if(canShow && S>=STRONG && Math.random()<0.25){
        return showdown(`${p.name} å‘èµ·å¼€ç‰Œ`);
      }
      advanceTurn();
    }

    function maybeAutoTurn(){ const p=state.players[state.turnIndex]; if(p && !p.isHuman) setTimeout(()=>botAct(p),600); }

    /* ---------- æ‘Šç‰Œ & ç»“æœ ---------- */
    function showdown(reason='å¼€ç‰Œ'){
      if(!state.inHand||state.showdown) return;
      state.inHand=false; state.showdown=true; log(`ã€${reason}ã€‘è¿›å…¥æ‘Šç‰Œ`);
      const alive=alivePlayers(); let best=null, winners=[];
      for(const p of alive){ const eva=evaluate3(p.hand);
        if(!best){best={p,eva};winners=[p];}
        else{ const cmp=compareHands(eva,best.eva); if(cmp>0){best={p,eva};winners=[p];} else if(cmp===0){winners.push(p);} }
      }
      if(winners.length===1){ winners[0].chips+=state.pot; log(`èµ¢å®¶ï¼š${winners[0].name}ï¼ˆ${evaluate3(winners[0].hand).name}ï¼‰ï¼Œèµ¢å¾— ï¿¥${state.pot}`); }
      else{ const share=Math.floor(state.pot/winners.length); for(const w of winners) w.chips+=share; log(`å¹³åˆ†åº•æ± ï¼š${winners.map(w=>w.name).join('ã€')} å„å¾— ï¿¥${share}`); }
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }
    function winByFold(p){
      state.inHand=false; state.showdown=true; p.chips+=state.pot; log(`å…¶ä½™ç©å®¶å¼ƒç‰Œï¼Œ${p.name} ç›´æ¥èµ¢å¾— ï¿¥${state.pot}`);
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }

    /* ---------- å¯åŠ¨ ---------- */
    document.getElementById('ante').textContent=cfg.ante;
    document.getElementById('maxBase').textContent=cfg.maxBase;
    document.getElementById('maxRounds').textContent=cfg.maxRounds;

    setupPlayers(); newHand();
  </script>
</body>
</html>
