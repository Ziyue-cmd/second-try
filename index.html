<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>扎金花 · 八座位（闷/看牌双倍注版）</title>

  <!-- 可选：PWA（若没有可先注释） -->
  <link rel="manifest" href="./manifest.json" />
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js', { scope: './' }).catch(console.error);
      });
    }
  </script>

  <style>
    :root{
      --bg:#0b1020; --felt:#0d1b2a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb;
      --accent:#22d3ee; --danger:#f43f5e; --ok:#10b981; --warn:#f59e0b; --border:#293241;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:8px;display:grid;gap:8px}

    .topbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{padding:3px 8px;border:1px solid var(--border);border-radius:10px;background:#0f172a;font-size:12px}
    .pot{font-weight:700;color:var(--accent)}
    .turn{color:var(--warn);font-weight:700}
    .ghost{opacity:.75}
    .btn{padding:6px 10px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:12px}

    .table{
      position:relative;height:520px;border:1px solid var(--border);border-radius:16px;
      background: radial-gradient(ellipse at center,#0f2a2a 0%, var(--felt) 60%, #0b1328 100%);
      overflow:hidden;
    }
    .seats{position:absolute; inset:0;}
    .center-pot{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(15,23,42,.85); border:1px solid var(--border); border-radius:10px;
      padding:4px 10px; font-size:13px; color:#e5e7eb; box-shadow:0 6px 16px rgba(0,0,0,.25);
    }

    .seat{
      position:absolute;width:150px;max-width:26vw;border:1px solid var(--border);
      border-radius:10px;background:var(--panel);padding:6px;box-shadow:0 6px 16px rgba(0,0,0,.2)
    }
    .seat h3{margin:0 0 4px;font-size:12px;display:flex;align-items:center;gap:6px}
    .chips{font-weight:700;color:var(--ok)}
    .folded{opacity:.55;filter:grayscale(.2)}
    .acting{outline:2px solid var(--warn)}

    /* 8 座位布局 */
    .pos-top    {left:50%; top:3%;   transform:translate(-50%,0);}
    .pos-tr     {left:78%; top:12%;  transform:translate(-50%,0);}
    .pos-right  {left:94%; top:50%;  transform:translate(-50%,-50%);}
    .pos-br     {left:78%; top:86%;  transform:translate(-50%,-50%);}
    .pos-bottom {left:50%; top:97%;  transform:translate(-50%,-100%);}
    .pos-bl     {left:22%; top:86%;  transform:translate(-50%,-50%);}
    .pos-left   {left:6%;  top:50%;  transform:translate(-50%,-50%);}
    .pos-tl     {left:22%; top:12%;  transform:translate(-50%,0);}

    .cards{display:flex;gap:4px;margin:4px 0 2px}
    .card{
      width:34px;height:48px;border-radius:6px;border:1px solid #374151;display:grid;place-items:center;
      background:#0b1328;font-weight:700;font-size:11px
    }
    .card.face{background:#f8fafc;color:#0b1020;border-color:#cbd5e1}
    .card small{font-size:9px}
    .suit-red{color:#ef4444}

    .actions{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
    button{
      padding:6px 10px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:12px
    }
    button.primary{background:#1d4ed8;border-color:#1e40af}
    button.danger{background:#991b1b;border-color:#7f1d1d}
    button:disabled{opacity:.5;cursor:not-allowed}

    .drawer{
      position:fixed;right:0;top:0;height:100vh;width:320px;max-width:90vw;
      background:var(--panel);border-left:1px solid var(--border);box-shadow:-10px 0 24px rgba(0,0,0,.35);
      transform:translateX(100%);transition:transform .25s ease;z-index:50;padding:12px;display:grid;gap:10px
    }
    .drawer.open{transform:translateX(0)}
    .panel{border:1px solid var(--border);border-radius:10px;background:#132033;padding:10px}
    .panel h4{margin:.2em 0 .6em;font-size:13px}
    .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #223049;padding:4px 0;font-size:12px}
    .log{height:260px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:#0f172a;padding:8px;font-size:12px;line-height:1.5}
    .log p{margin:.2em 0;color:#c0cad6}

    @media (max-width:980px){
      .wrap{max-width:100%;padding:6px}
      .table{height:480px}
      .seat{width:138px}
      .card{width:32px;height:46px}
    }
    @media (max-width:720px){
      .seat{width:130px}
      .card{width:30px;height:44px;font-size:10px}
      .card small{font-size:8px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <button id="btnMenu" class="btn">菜单</button>
      <span class="badge">底注: <b id="ante">10</b></span>
      <span class="badge">本轮盲: <b id="roundBase">10</b></span>
      <span class="badge">盲上限: <b id="maxBase">20</b>（看牌=×2）</span>
      <span class="badge">闷注上限(轮): <b id="maxRounds">30</b></span>
      <span class="badge">轮到: <span id="turnName" class="turn">-</span></span>
      <span class="badge ghost">当前轮: <b id="roundNow">1</b></span>
    </div>

    <div class="table">
      <div class="seats" id="seats"></div>
      <div class="center-pot">底池（Pot）：<span class="pot" id="pot">0</span></div>
    </div>
  </div>

  <!-- 侧栏抽屉 -->
  <aside class="drawer" id="drawer">
    <div class="panel">
      <h4>局面</h4>
      <div class="kv"><span>底池</span><b id="statPot">0</b></div>
      <div class="kv"><span>本轮盲</span><b id="statRoundBase">10</b></div>
      <div class="kv"><span>当前轮</span><b id="statRound">1</b></div>
      <div class="kv"><span>存活玩家</span><b id="statAlive">8</b></div>
    </div>
    <div class="panel">
      <h4>你（玩家）</h4>
      <div class="kv"><span>筹码</span><b id="meChips">0</b></div>
      <div class="kv"><span>你本轮已下</span><b id="meBet">0</b></div>
      <div class="kv"><span>状态</span><b id="meState">闷</b></div>
    </div>
    <div class="panel">
      <h4>日志</h4>
      <div class="log" id="log"></div>
    </div>
    <button id="btnClose" class="btn">关闭</button>
  </aside>

  <script>
    /* ---------- 工具 & 牌面 ---------- */
    const SUITS=['♠','♥','♦','♣'], RANKS=[2,3,4,5,6,7,8,9,10,11,12,13,14];
    const RANK_LABEL=v=>({11:'J',12:'Q',13:'K',14:'A'}[v]||String(v)), isRed=s=>(s==='♥'||s==='♦');
    const createDeck=()=>{const d=[];for(const s of SUITS)for(const r of RANKS)d.push({suit:s,rank:r});return d;};
    const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]];}return a;};

    function evaluate3(hand){
      const ranks=hand.map(c=>c.rank).sort((a,b)=>b-a), suits=hand.map(c=>c.suit);
      const isFlush=(new Set(suits)).size===1;
      function straightHigh(rs){
        const r=[...new Set(rs)].sort((a,b)=>a-b); if(r.length!==3)return null;
        if(r[1]===r[0]+1&&r[2]===r[1]+1) return r[2];
        const r2=r.map(x=>x===14?1:x).sort((a,b)=>a-b);
        if(r2[1]===r2[0]+1&&r2[2]===r2[1]+1) return r2[2];
        return null;
      }
      const sh=straightHigh(ranks), counts={}; for(const r of ranks) counts[r]=(counts[r]||0)+1;
      const groups=Object.entries(counts).map(([r,c])=>({r:+r,c}));
      if(groups.some(g=>g.c===3)) return{cat:6,scoreVec:[groups.find(g=>g.c===3).r],name:'豹子(三条)'};
      if(isFlush&&sh!==null) return{cat:5,scoreVec:[sh],name:'同花顺'};
      if(isFlush) return{cat:4,scoreVec:ranks,name:'同花'};
      if(sh!==null) return{cat:3,scoreVec:[sh],name:'顺子'};
      if(groups.some(g=>g.c===2)){const pair=groups.find(g=>g.c===2).r;const kick=groups.find(g=>g.c===1).r;return{cat:2,scoreVec:[pair,kick],name:'对子'};}
      return{cat:1,scoreVec:ranks,name:'高牌'};
    }
    const compareHands=(a,b)=> a.cat!==b.cat ? a.cat-b.cat :
      (()=>{for(let i=0;i<Math.max(a.scoreVec.length,b.scoreVec.length);i++){const av=a.scoreVec[i]??0,bv=b.scoreVec[i]??0;if(av!==bv)return av-bv;}return 0;})();

    /* ---------- 配置 & 状态 ---------- */
    const cfg = { ante:10, startBase:10, maxBase:20, maxRounds:30, startChips:1000 };
    const state = {
      players: [], deck: [], pot: 0,
      roundIndex: 1, roundBase: cfg.startBase,
      turnIndex: 0, inHand: false, showdown: false
    };

    /* ---------- DOM & 抽屉 ---------- */
    const seatsEl=document.getElementById('seats'), logEl=document.getElementById('log');
    const potEl=document.getElementById('pot'), roundBaseEl=document.getElementById('roundBase'), maxBaseEl=document.getElementById('maxBase');
    const turnEl=document.getElementById('turnName'), roundNowEl=document.getElementById('roundNow');
    const statPotEl=document.getElementById('statPot'), statRoundBaseEl=document.getElementById('statRoundBase');
    const statAliveEl=document.getElementById('statAlive'), statRoundEl=document.getElementById('statRound');
    const meChipsEl=document.getElementById('meChips'), meBetEl=document.getElementById('meBet'), meStateEl=document.getElementById('meState');
    const drawer=document.getElementById('drawer');
    document.getElementById('btnMenu').onclick=()=>drawer.classList.add('open');
    document.getElementById('btnClose').onclick=()=>drawer.classList.remove('open');
    function log(msg){const p=document.createElement('p');p.textContent=msg;logEl.appendChild(p);logEl.scrollTop=logEl.scrollHeight;}

    /* ---------- 初始化 ---------- */
    function setupPlayers(){
      state.players=[
        {id:0,name:'机器人A',pos:'pos-top',   isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:1,name:'机器人B',pos:'pos-tr',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:2,name:'机器人C',pos:'pos-right', isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:3,name:'机器人D',pos:'pos-br',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:4,name:'你(玩家)',pos:'pos-bottom',isHuman:true,  chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:5,name:'机器人E',pos:'pos-bl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:6,name:'机器人F',pos:'pos-left',  isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
        {id:7,name:'机器人G',pos:'pos-tl',    isHuman:false, chips:cfg.startChips,hand:[],folded:false,seen:false,betThisRound:0},
      ];
    }
    const alivePlayers=()=>state.players.filter(p=>!p.folded && p.chips>=0);

    function newHand(){
      state.inHand=true; state.showdown=false; state.pot=0;
      state.roundIndex=1; state.roundBase=cfg.startBase; state.turnIndex=0;
      state.deck=shuffle(createDeck());
      for(const p of state.players){ p.hand=[state.deck.pop(),state.deck.pop(),state.deck.pop()]; p.folded=false; p.seen=false; p.betThisRound=0; }
      for(const p of alivePlayers()){ const ante=Math.min(cfg.ante,p.chips); p.chips-=ante; state.pot+=ante; }
      log('—— 新一局开始（默认闷），收取盲底注 ——');
      render(); maybeAutoTurn();
    }

    /* ---------- 目标与需求：看牌=盲×2 ---------- */
    const targetFor = p => state.roundBase * (p.seen ? 2 : 1);
    const needFor   = p => Math.max(0, targetFor(p) - p.betThisRound);

    /* ---------- 渲染（机器人看牌也不亮牌） ---------- */
    function seatHtml(p,acting){
      const canSeeCards = p.isHuman ? (p.seen || state.showdown || p.folded) : (state.showdown || p.folded);
      const cards=p.hand.map(c=> canSeeCards
        ? `<div class="card face ${isRed(c.suit)?'suit-red':''}">${RANK_LABEL(c.rank)}<small>${c.suit}</small></div>`
        : `<div class="card">🂠</div>`).join('');
      const stateTag = p.seen ? '看' : '闷';
      return `
        <div class="seat ${p.pos} ${p.folded?'folded':''} ${acting?'acting':''}">
          <h3>${p.name} <span class="chips">￥${p.chips}</span> <span style="margin-left:auto;font-size:11px;color:#9fb0c1">[${stateTag}]</span> ${acting?'<span class="turn">（行动）</span>':''}</h3>
          <div class="cards">${cards}</div>
          <div style="font-size:11px;color:#9fb0c1;display:flex;gap:8px">
            <span>已下：￥${p.betThisRound}</span><span>需至：￥${targetFor(p)}</span>
          </div>
          ${p.isHuman?humanActionsHtml():''}
        </div>`;
    }
    function humanActionsHtml(){
      return `<div class="actions" id="actionBar">
        <button id="btnSee">看牌</button>
        <button id="btnFold" class="danger">弃牌</button>
        <button id="btnCall">跟注</button>
        <button id="btnRaise" class="primary">加注(盲×2)</button>
        <button id="btnShowdown" title="仅剩一名对手时可开牌">开牌</button>
        <button id="btnNext" style="display:none;">下一局</button>
      </div>`;
    }

    function render(){
      potEl.textContent=state.pot;
      roundBaseEl.textContent=state.roundBase;
      maxBaseEl.textContent=cfg.maxBase;
      turnEl.textContent=state.inHand?state.players[state.turnIndex].name:'-';
      statPotEl.textContent=state.pot;
      statRoundBaseEl.textContent=state.roundBase;
      statRoundEl.textContent=state.roundIndex;
      const alive=alivePlayers();
      statAliveEl.textContent=alive.length;
      roundNowEl.textContent=state.roundIndex;

      const me=state.players[4];
      meChipsEl.textContent=me.chips;
      meBetEl.textContent=me.betThisRound;
      meStateEl.textContent=me.seen?'看':'闷';

      seatsEl.innerHTML='';
      state.players.forEach((p,i)=>seatsEl.insertAdjacentHTML('beforeend',seatHtml(p, state.inHand && i===state.turnIndex && !state.showdown && !p.folded)));

      const myTurn = state.inHand && !state.showdown && !me.folded && state.turnIndex===4;
      const btnSee=document.getElementById('btnSee'),
            btnFold=document.getElementById('btnFold'),
            btnCall=document.getElementById('btnCall'),
            btnRaise=document.getElementById('btnRaise'),
            btnShow=document.getElementById('btnShowdown'),
            btnNext=document.getElementById('btnNext');

      if(btnSee){ btnSee.disabled=!(myTurn && !me.seen); btnSee.onclick=()=>playerSee(); }
      if(btnFold){ btnFold.disabled=!myTurn; btnFold.onclick=()=>playerFold(); }
      if(btnCall){ btnCall.disabled=!myTurn; btnCall.onclick=()=>playerCall(); }
      if(btnRaise){ btnRaise.disabled=!(myTurn && state.roundBase < cfg.maxBase); btnRaise.onclick=()=>playerRaise(); }
      if(btnShow){ btnShow.disabled=!(state.inHand && !state.showdown && alive.length===2 && myTurn); btnShow.onclick=()=>showdown('玩家开牌'); }
      if(btnNext){ btnNext.style.display=(!state.inHand && state.showdown)?'inline-block':'none'; btnNext.onclick=()=>newHand(); }
    }

    /* ---------- 行动 ---------- */
    const payToPot=(p,amount)=>{const pay=Math.max(0,Math.min(amount,p.chips));p.chips-=pay;p.betThisRound+=pay;state.pot+=pay;return pay;};

    function playerSee(){ const me=state.players[4]; if(me.seen) return; me.seen=true; log('你选择：看牌（之后你的跟注=盲×2）'); render(); }
    function playerFold(){ const me=state.players[4]; me.folded=true; log('你选择：弃牌'); advanceTurn(); }
    function playerCall(){ const me=state.players[4]; const need=needFor(me); const paid=payToPot(me,need); log(`你：跟注 ￥${paid}（盲=${state.roundBase}，你的目标=${targetFor(me)}）`); advanceTurn(); }
    function playerRaise(){
      const me=state.players[4];
      if(state.roundBase>=cfg.maxBase){ return playerCall(); }
      const needCall = needFor(me);
      const paidCall = payToPot(me, needCall);
      state.roundBase = Math.min(state.roundBase*2, cfg.maxBase);
      log(`你：先补 ￥${paidCall}，把盲提升至 ￥${state.roundBase}${me.seen?'（你看牌，目标=盲×2）':''}`);
      const needAfter = needFor(me);
      if(needAfter>0){ const paidRaise = payToPot(me, needAfter); log(`你：为满足新目标再补 ￥${paidRaise}（新目标=${targetFor(me)}）`); }
      advanceTurn();
    }

    /* ---------- 回合推进 & 闷注上限 ---------- */
    const allMatched=()=>alivePlayers().every(p=>p.betThisRound===targetFor(p));

    function advanceTurn(){
      const alive=alivePlayers();
      if(alive.length===1) return winByFold(alive[0]);

      if(allMatched()){
        if(state.roundIndex >= cfg.maxRounds){ return showdown('达到闷注上限，强制开牌'); }
        state.roundIndex += 1;
        state.roundBase = cfg.startBase;
        for(const p of alive) p.betThisRound = 0;
        log(`—— 进入第 ${state.roundIndex} 轮（盲重置 ￥${state.roundBase}；看牌者目标=￥${state.roundBase*2}）——`);
      }

      const n=state.players.length;
      for(let step=1; step<=n; step++){
        const idx=(state.turnIndex+step)%n; const cand=state.players[idx];
        if(!cand.folded){ state.turnIndex=idx; break; }
      }
      render(); maybeAutoTurn();
    }

    /* ---------- 机器人逻辑 ---------- */
    function botStrength(p){
      if(!p.seen){ return 200 + Math.random()*100; } // 未看牌：弱信息，鼓励闷和小跟
      const eva=evaluate3(p.hand); let minor=0; if(eva.scoreVec?.length) minor=eva.scoreVec.reduce((acc,v,i)=>acc+v*Math.pow(0.01,i),0);
      return eva.cat*100+minor;
    }
    function botMaybeSee(p){
      if(p.seen||p.folded) return;
      const need=needFor(p);
      const pressure = need / 20;
      const baseProb = Math.min(0.08 + 0.03*(state.roundIndex-1) + 0.10*pressure, 0.55);
      if(Math.random()<baseProb){ p.seen=true; log(`${p.name}：看牌`); }
    }
    function botAct(p){
      if(!state.inHand||state.showdown||p.folded) return;
      const alive = alivePlayers();
      const canShow = alive.length===2;

      botMaybeSee(p);

      const need=needFor(p);
      const S=botStrength(p);
      const STRONG=520, MEDIUM=260;

      const canRaiseBase = state.roundBase < cfg.maxBase;
      if(S>=STRONG && canRaiseBase){
        payToPot(p, need);
        state.roundBase = cfg.maxBase;
        log(`${p.name}：提升盲至 ￥${state.roundBase}${p.seen?'（其目标=￥40）':'（其目标=￥20）'}`);
        const needAfter = needFor(p);
        if(needAfter>0){ payToPot(p, needAfter); }
        return advanceTurn();
      }

      if(S>=MEDIUM || need===0){
        const paid=payToPot(p,need); log(`${p.name}：跟注 ￥${paid}`);
      }else{
        if(need>0 && Math.random()<0.40){ p.folded=true; log(`${p.name}：弃牌`); }
        else{ const paid=payToPot(p,need); log(`${p.name}：跟注 ￥${paid}`); }
      }

      if(canShow && S>=STRONG && Math.random()<0.25){
        return showdown(`${p.name} 发起开牌`);
      }
      advanceTurn();
    }
    const maybeAutoTurn=()=>{ const p=state.players[state.turnIndex]; if(p && !p.isHuman) setTimeout(()=>botAct(p),560); };

    /* ---------- 摊牌 & 结果 ---------- */
    function showdown(reason='开牌'){
      if(!state.inHand||state.showdown) return;
      state.inHand=false; state.showdown=true; log(`【${reason}】进入摊牌`);
      const alive=alivePlayers(); let best=null, winners=[];
      for(const p of alive){ const eva=evaluate3(p.hand);
        if(!best){best={p,eva};winners=[p];}
        else{ const cmp=compareHands(eva,best.eva); if(cmp>0){best={p,eva};winners=[p];} else if(cmp===0){winners.push(p);} }
      }
      if(winners.length===1){ winners[0].chips+=state.pot; log(`赢家：${winners[0].name}（${evaluate3(winners[0].hand).name}），赢得 ￥${state.pot}`); }
      else{ const share=Math.floor(state.pot/winners.length); for(const w of winners) w.chips+=share; log(`平分底池：${winners.map(w=>w.name).join('、')} 各得 ￥${share}`); }
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }
    function winByFold(p){
      state.inHand=false; state.showdown=true; p.chips+=state.pot; log(`其余玩家弃牌，${p.name} 直接赢得 ￥${state.pot}`);
      state.pot=0; render(); const btnNext=document.getElementById('btnNext'); if(btnNext) btnNext.style.display='inline-block';
    }

    /* ---------- 启动 ---------- */
    document.getElementById('ante').textContent=cfg.ante;
    document.getElementById('maxBase').textContent=cfg.maxBase;
    document.getElementById('maxRounds').textContent=cfg.maxRounds;

    setupPlayers();
    newHand();
  </script>
</body>
</html>
