<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>æ‰é‡‘èŠ± Â· å››åº§ä½ï¼ˆ1 äºº + 3 æœºå™¨äººï¼‰</title>

  <!-- å¯é€‰ï¼šPWA æ–‡ä»¶ï¼ˆè‹¥æ²¡æœ‰å¯å…ˆæ³¨é‡Šæ‰ï¼‰ -->
  <link rel="manifest" href="./manifest.json" />
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch(console.error);
      });
    }
  </script>

  <style>
    :root{
      --bg:#0b1020;
      --felt:#0d1b2a;
      --panel:#111827;
      --muted:#9ca3af;
      --text:#e5e7eb;
      --accent:#22d3ee;
      --danger:#f43f5e;
      --ok:#10b981;
      --warn:#f59e0b;
      --border:#293241;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:1100px;margin:0 auto;padding:12px;display:grid;gap:12px}

    /* é¡¶éƒ¨ä¿¡æ¯æ¡ */
    .topbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .badge{padding:4px 8px;border:1px solid var(--border);border-radius:10px;background:#0f172a}
    .pot{font-weight:700;color:var(--accent)}
    .turn{color:var(--warn);font-weight:700}

    /* æ¡Œé¢ä¸åº§ä½å¸ƒå±€ */
    .table{
      position:relative;
      height:600px; /* æ¡Œé¢é«˜åº¦ï¼Œå¯è°ƒ */
      border:1px solid var(--border);
      border-radius:16px;
      background: radial-gradient(ellipse at center, #0f2a2a 0%, var(--felt) 60%, #0b1328 100%);
      overflow:hidden;
    }
    .center-info{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      text-align:center; color:#cbd5e1; font-size:14px;
    }
    .center-info h2{margin:.2em 0 .4em; font-size:20px}
    .seats{
      position:absolute; inset:0;
    }

    .seat{
      position:absolute;
      width:260px; max-width:38vw;
      border:1px solid var(--border); border-radius:12px; background:var(--panel);
      padding:8px;
      box-shadow:0 8px 24px rgba(0,0,0,.25);
    }
    .seat h3{margin:0 0 6px; font-size:16px; display:flex; align-items:center; gap:8px}
    .chips{font-weight:700;color:var(--ok)}
    .folded{opacity:.55; filter:grayscale(.2)}
    .acting{outline:2px solid var(--warn)}
    /* å››ä¸ªåº§ä½çš„ä½ç½®ï¼ˆä¸Šã€å³ã€ä¸‹ã€å·¦ï¼‰ */
    .seat.top{left:50%; top:8px; transform:translateX(-50%)}
    .seat.right{right:8px; top:50%; transform:translateY(-50%)}
    .seat.bottom{left:50%; bottom:8px; transform:translateX(-50%)}
    .seat.left{left:8px; top:50%; transform:translateY(-50%)}

    /* æ‰‘å…‹ç‰Œæ˜¾ç¤º */
    .cards{display:flex;gap:8px;margin:6px 0 2px}
    .card{
      width:52px;height:72px;border-radius:8px;border:1px solid #374151;display:grid;place-items:center;
      background:#0b1328;font-weight:700;
    }
    .card.face{background:#f8fafc;color:#0b1020;border-color:#cbd5e1}
    .suit-red{color:#ef4444}

    /* æ“ä½œæ  */
    .actions{
      margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;
    }
    button{
      padding:8px 12px;border-radius:10px;border:1px solid #374151;background:#1f2937;color:#e5e7eb;cursor:pointer;
    }
    button.primary{background:#1d4ed8;border-color:#1e40af}
    button.danger{background:#991b1b;border-color:#7f1d1d}
    button:disabled{opacity:.5;cursor:not-allowed}

    /* ä¾§è¾¹ä¿¡æ¯åŒº */
    .sidebar{display:grid;gap:12px}
    .panel{border:1px solid var(--border);border-radius:12px;background:var(--panel);padding:12px}
    .panel h4{margin:.2em 0 .6em}
    .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #223049;padding:4px 0}
    .log{height:180px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:#0f172a;padding:8px;font-size:13px;line-height:1.5}
    .log p{margin:.2em 0;color:#c0cad6}
    @media (max-width:980px){
      .wrap{max-width:100%; padding:8px}
      .table{height:520px}
      .seat{width:220px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- é¡¶éƒ¨çŠ¶æ€æ¡ -->
    <div class="topbar">
      <span class="badge">åº•æ³¨(Ante): <b id="ante">10</b></span>
      <span class="badge">å•ä½åŠ æ³¨: <b id="unitBet">10</b></span>
      <span class="badge">æœ€å¤§åŠ æ³¨/è½®: <b id="maxRaises">3</b></span>
      <span class="badge">æœ€å¤§è½®æ¬¡: <b id="maxRounds">20</b></span>
      <span class="badge">åº•æ±  Pot: <span class="pot" id="pot">0</span></span>
      <span class="badge">å½“å‰éœ€è·Ÿæ³¨: <b id="currentBet">0</b></span>
      <span class="badge">è½®åˆ°: <span id="turnName" class="turn">-</span></span>
      <span class="badge">å½“å‰è½®æ¬¡: <b id="roundNow">1</b></span>
    </div>

    <!-- ä¸»æ¡Œé¢ + åº§ä½ -->
    <div class="table">
      <div class="seats" id="seats"></div>

      <div class="center-info">
        <h2>æ‰é‡‘èŠ±</h2>
        <div>å½“æ‰€æœ‰æœªå¼ƒç‰Œè€…åœ¨æŸä¸€è½®â€œä¸‹åˆ°åŒé¢â€ â†’ è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€è½®ã€‚</div>
        <div>ä½ å¯éšæ—¶ç‚¹å‡» <b>å¼€ç‰Œ</b>ï¼Œæˆ–æœºå™¨äººåœ¨è‹¥å¹²è½®åéšæœºå¼€ç‰Œã€‚</div>
      </div>
    </div>

    <!-- ä¾§æ  -->
    <div class="sidebar">
      <div class="panel">
        <h4>å±€é¢</h4>
        <div class="kv"><span>åº•æ± </span><b id="statPot">0</b></div>
        <div class="kv"><span>å½“å‰è·Ÿæ³¨</span><b id="statNeed">0</b></div>
        <div class="kv"><span>å·²åŠ æ³¨æ¬¡æ•°ï¼ˆæœ¬è½®ï¼‰</span><b id="statRaises">0</b></div>
        <div class="kv"><span>å½“å‰è½®æ¬¡</span><b id="statRound">1</b></div>
        <div class="kv"><span>å­˜æ´»ç©å®¶</span><b id="statAlive">4</b></div>
      </div>
      <div class="panel">
        <h4>ä½ ï¼ˆç©å®¶ï¼‰</h4>
        <div class="kv"><span>ç­¹ç </span><b id="meChips">0</b></div>
        <div class="kv"><span>ä½ æœ¬è½®å·²ä¸‹</span><b id="meBet">0</b></div>
      </div>
      <div class="panel">
        <h4>æ—¥å¿—</h4>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * å·¥å…· & ç‰Œé¢
     ***********************/
    const SUITS = ['â™ ','â™¥','â™¦','â™£'];
    const RANKS = [2,3,4,5,6,7,8,9,10,11,12,13,14]; // 11=J,12=Q,13=K,14=A
    const RANK_LABEL = v => ({11:'J',12:'Q',13:'K',14:'A'}[v] || String(v));
    const isRed = s => (s==='â™¥' || s==='â™¦');

    function createDeck(){
      const d = [];
      for (const s of SUITS) for (const r of RANKS) d.push({suit:s, rank:r});
      return d;
    }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; }
      return a;
    }

    /***********************
     * æ‰‹ç‰Œè¯„ä¼°ï¼ˆæ‰é‡‘èŠ±ï¼‰
     * è¿”å› {cat, scoreVec, name}
     * cat è¶Šå¤§è¶Šå¼ºï¼š6è±¹å­,5åŒèŠ±é¡º,4åŒèŠ±,3é¡ºå­,2å¯¹å­,1é«˜ç‰Œ
     ***********************/
    function evaluate3(hand){
      const ranks = hand.map(c=>c.rank).sort((a,b)=>b-a);
      const suits = hand.map(c=>c.suit);
      const isFlush = (new Set(suits)).size===1;

      function straightHigh(rs){
        const r=[...new Set(rs)].sort((a,b)=>a-b);
        if(r.length!==3) return null;
        if(r[1]===r[0]+1 && r[2]===r[1]+1) return r[2];
        const r2=r.map(x=>x===14?1:x).sort((a,b)=>a-b);
        if(r2[1]===r2[0]+1 && r2[2]===r2[1]+1) return r2[2]; // 3 (A-2-3)
        return null;
      }
      const sh=straightHigh(ranks);
      const counts={}; for(const r of ranks) counts[r]=(counts[r]||0)+1;
      const groups=Object.entries(counts).map(([r,c])=>({r:+r,c}));

      if(groups.some(g=>g.c===3)) { const v=groups.find(g=>g.c===3).r; return {cat:6,scoreVec:[v],name:'è±¹å­(ä¸‰æ¡)'}; }
      if(isFlush && sh!==null)    return {cat:5,scoreVec:[sh],name:'åŒèŠ±é¡º'};
      if(isFlush)                 return {cat:4,scoreVec:ranks,name:'åŒèŠ±'};
      if(sh!==null)               return {cat:3,scoreVec:[sh],name:'é¡ºå­'};
      if(groups.some(g=>g.c===2)){
        const pair=groups.find(g=>g.c===2).r; const kick=groups.find(g=>g.c===1).r;
        return {cat:2,scoreVec:[pair,kick],name:'å¯¹å­'};
      }
      return {cat:1,scoreVec:ranks,name:'é«˜ç‰Œ'};
    }
    function compareHands(a,b){
      if(a.cat!==b.cat) return a.cat-b.cat;
      for(let i=0;i<Math.max(a.scoreVec.length,b.scoreVec.length);i++){
        const av=a.scoreVec[i]??0, bv=b.scoreVec[i]??0;
        if(av!==bv) return av-bv;
      }
      return 0;
    }

    /***********************
     * é…ç½® & çŠ¶æ€ï¼ˆæ”¯æŒå¤šè½®ä¸‹æ³¨ï¼‰
     ***********************/
    const cfg = {
      ante: 10,
      unitBet: 10,
      maxRaisesPerRound: 3,
      maxRounds: 20,
      startChips: 500
    };
    const state = {
      players: [],   // {id,name,pos,isHuman,chips,hand,folded,betThisRound,totalBet}
      deck: [],
      pot: 0,
      roundIndex: 1,
      raisesThisRound: 0,
      currentBet: 0,
      turnIndex: 0,
      inHand: false,
      showdown: false
    };
    const POSITIONS = ['top','right','bottom','left']; // 0~3

    /***********************
     * DOM refs & log
     ***********************/
    const seatsEl = document.getElementById('seats');
    const logEl = document.getElementById('log');
    const potEl = document.getElementById('pot');
    const needEl = document.getElementById('currentBet');
    const turnEl = document.getElementById('turnName');
    const meChipsEl = document.getElementById('meChips');
    const meBetEl = document.getElementById('meBet');
    const statPotEl = document.getElementById('statPot');
    const statNeedEl = document.getElementById('statNeed');
    const statRaisesEl = document.getElementById('statRaises');
    const statAliveEl = document.getElementById('statAlive');
    const statRoundEl = document.getElementById('statRound');
    const roundNowEl = document.getElementById('roundNow');

    function log(msg){
      const p=document.createElement('p'); p.textContent=msg; logEl.appendChild(p);
      logEl.scrollTop=logEl.scrollHeight;
    }

    /***********************
     * åˆå§‹åŒ– & å¼€æ–°å±€
     ***********************/
    function setupPlayers(){
      state.players = [
        {id:0, name:'ä½ (ç©å®¶)', pos:'bottom', isHuman:true,  chips:cfg.startChips, hand:[], folded:false, betThisRound:0, totalBet:0},
        {id:1, name:'æœºå™¨äººA', pos:'left',   isHuman:false, chips:cfg.startChips, hand:[], folded:false, betThisRound:0, totalBet:0},
        {id:2, name:'æœºå™¨äººB', pos:'top',    isHuman:false, chips:cfg.startChips, hand:[], folded:false, betThisRound:0, totalBet:0},
        {id:3, name:'æœºå™¨äººC', pos:'right',  isHuman:false, chips:cfg.startChips, hand:[], folded:false, betThisRound:0, totalBet:0},
      ];
    }

    function newHand(){
      state.inHand = true;
      state.showdown = false;
      state.pot = 0;
      state.roundIndex = 1;
      state.raisesThisRound = 0;
      state.currentBet = 0;
      state.turnIndex = 0;

      state.deck = shuffle(createDeck());
      for(const p of state.players){
        p.hand = [state.deck.pop(), state.deck.pop(), state.deck.pop()];
        p.folded=false; p.betThisRound=0; p.totalBet=0;
      }
      // åº•æ³¨
      for(const p of alivePlayers()){
        const antePay=Math.min(cfg.ante,p.chips); p.chips-=antePay; state.pot+=antePay; p.totalBet+=antePay;
      }
      log('â€”â€” æ–°ä¸€å±€å¼€å§‹ï¼Œæ”¶å–åº•æ³¨ â€”â€”');
      render();
      maybeAutoTurn();
    }

    function alivePlayers(){ return state.players.filter(p=>!p.folded && p.chips>=0); }

    /***********************
     * æ¸²æŸ“åº§ä½ & æŒ‰é’®
     ***********************/
    function seatHtml(p, acting){
      const faceUp = p.isHuman || state.showdown || p.folded;
      const cards = p.hand.map(c=>{
        if(faceUp){
          const red = isRed(c.suit) ? 'suit-red':'';
          return `<div class="card face ${red}">${RANK_LABEL(c.rank)}<small>${c.suit}</small></div>`;
        }else{
          return `<div class="card">ğŸ‚ </div>`;
        }
      }).join('');
      const eva = (state.showdown || p.folded) ? `<div style="font-size:12px;color:#cbd5e1">ç‰Œå‹ï¼š<b>${evaluate3(p.hand).name}</b></div>` : '';
      return `
        <div class="seat ${p.pos} ${p.folded?'folded':''} ${acting?'acting':''}">
          <h3>${p.name} <span class="chips">ï¿¥${p.chips}</span> ${acting?'<span class="turn">ï¼ˆè¡ŒåŠ¨ï¼‰</span>':''}</h3>
          <div class="cards">${cards}</div>
          <div style="font-size:12px;color:#9fb0c1;display:flex;gap:10px">
            <span>æœ¬è½®ä¸‹æ³¨ï¼šï¿¥${p.betThisRound}</span>
            <span>æ€»æŠ•å…¥ï¼šï¿¥${p.totalBet}</span>
          </div>
          ${eva}
          ${p.isHuman ? humanActionsHtml() : ''}
        </div>
      `;
    }

    function humanActionsHtml(){
      // ç©å®¶æ“ä½œï¼šå¼ƒç‰Œã€è·Ÿæ³¨ã€åŠ æ³¨ã€å¼€ç‰Œã€ä¸‹ä¸€å±€
      return `
        <div class="actions" id="actionBar">
          <button id="btnFold" class="danger">å¼ƒç‰Œ</button>
          <button id="btnCall">è·Ÿæ³¨</button>
          <button id="btnRaise" class="primary">åŠ æ³¨</button>
          <button id="btnShowdown" title="ä¸»åŠ¨å¼€ç‰Œ">å¼€ç‰Œ</button>
          <button id="btnNext" style="display:none;">ä¸‹ä¸€å±€</button>
        </div>
      `;
    }

    function render(){
      // é¡¶éƒ¨/ä¾§æ æ•°å€¼
      potEl.textContent = state.pot;
      needEl.textContent = state.currentBet;
      turnEl.textContent = state.inHand ? state.players[state.turnIndex].name : '-';
      statPotEl.textContent = state.pot;
      statNeedEl.textContent = state.currentBet;
      statRaisesEl.textContent = state.raisesThisRound;
      statAliveEl.textContent = alivePlayers().length;
      statRoundEl.textContent = state.roundIndex;
      roundNowEl.textContent = state.roundIndex;
      meChipsEl.textContent = state.players[0].chips;
      meBetEl.textContent = state.players[0].betThisRound;

      // åº§ä½
      seatsEl.innerHTML = '';
      state.players.forEach((p,i)=>{
        const acting = (state.inHand && i===state.turnIndex && !state.showdown && !p.folded);
        seatsEl.insertAdjacentHTML('beforeend', seatHtml(p, acting));
      });

      // ç»‘å®šç©å®¶æŒ‰é’®ï¼ˆç”±äºæ¯æ¬¡é‡æ¸²æŸ“è¦é‡æ–°ç»‘å®šï¼‰
      const myTurn = canHumanAct();
      const btnFold = document.getElementById('btnFold');
      const btnCall = document.getElementById('btnCall');
      const btnRaise = document.getElementById('btnRaise');
      const btnShow = document.getElementById('btnShowdown');
      const btnNext  = document.getElementById('btnNext');

      if (btnFold){
        btnFold.disabled = !myTurn; btnFold.onclick = ()=>{ playerFold(); };
      }
      if (btnCall){
        btnCall.disabled = !myTurn; btnCall.onclick = ()=>{ playerCall(); };
      }
      if (btnRaise){
        btnRaise.disabled = !(myTurn && state.raisesThisRound < cfg.maxRaisesPerRound);
        btnRaise.onclick = ()=>{ playerRaise(); };
      }
      if (btnShow){
        btnShow.disabled = !(state.inHand && !state.showdown); // éšæ—¶å¯ç‚¹å¼€ç‰Œï¼Œåªè¦åœ¨ç‰Œå±€ä¸­
        btnShow.onclick = ()=>{ showdown('ç©å®¶ä¸»åŠ¨å¼€ç‰Œ'); };
      }
      if (btnNext){
        btnNext.style.display = (!state.inHand && state.showdown) ? 'inline-block' : 'none';
        btnNext.onclick = ()=>{ newHand(); };
      }
    }

    function canHumanAct(){
      return state.inHand && !state.showdown &&
             !state.players[0].folded &&
             state.turnIndex===0;
    }

    /***********************
     * ä¸‹æ³¨/è¡ŒåŠ¨æ ¸å¿ƒ
     ***********************/
    function payToPot(p, amount){
      const pay = Math.max(0, Math.min(amount, p.chips));
      p.chips -= pay;
      p.betThisRound += pay;
      p.totalBet += pay;
      state.pot += pay;
      return pay;
    }

    function playerFold(){
      const me=state.players[0];
      me.folded = true; log(`ä½ é€‰æ‹©ï¼šå¼ƒç‰Œ`);
      advanceTurn();
    }
    function playerCall(){
      const me=state.players[0];
      const need = Math.max(0, state.currentBet - me.betThisRound);
      const paid = payToPot(me, need);
      log(`ä½ é€‰æ‹©ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
      advanceTurn();
    }
    function playerRaise(){
      const me=state.players[0];
      if (state.raisesThisRound >= cfg.maxRaisesPerRound) return;
      const need = Math.max(0, state.currentBet - me.betThisRound);
      const paidCall = payToPot(me, need);
      state.currentBet += cfg.unitBet;
      state.raisesThisRound += 1;
      const paidRaise = payToPot(me, cfg.unitBet);
      log(`ä½ ï¼šå…ˆè·Ÿ ï¿¥${paidCall} å†åŠ æ³¨ ï¿¥${paidRaise}ï¼ˆå½“å‰éœ€è·Ÿæ³¨=${state.currentBet}ï¼‰`);
      advanceTurn();
    }

    function advanceTurn(){
      // æ˜¯å¦åªå‰©ä¸€äººå­˜æ´» â†’ ç«‹å³èƒœå‡º
      const alive = alivePlayers();
      if (alive.length===1){ return winByFold(alive[0]); }

      // ä¸€è½®æ˜¯å¦ç»“æŸï¼šæ‰€æœ‰æœªå¼ƒç‰Œè€…éƒ½è·Ÿåˆ°åŒé¢
      const target = Math.max(...alive.map(p=>p.betThisRound));
      const allMatched = alive.every(p=>p.betThisRound===target);
      if (allMatched){
        // è¿›å…¥ä¸‹ä¸€è½® or ç»“æŸï¼ˆå¦‚æœè¾¾åˆ° maxRoundsï¼‰
        if (state.roundIndex >= cfg.maxRounds){
          return showdown('è¾¾åˆ°æœ€å¤§è½®æ¬¡ï¼Œå¼ºåˆ¶å¼€ç‰Œ');
        }else{
          // æ¸…ç†è¿›å…¥ä¸‹ä¸€è½®
          state.roundIndex += 1;
          state.raisesThisRound = 0;
          state.currentBet = 0;
          for (const p of alive){ p.betThisRound = 0; }
          log(`â€”â€” è¿›å…¥ç¬¬ ${state.roundIndex} è½® â€”â€”`);
          // æ–°ä¸€è½®ä»ä¸‹ä¸€ä½è¡ŒåŠ¨è€…å¼€å§‹
        }
      }

      // é¡ºæ—¶é’ˆæ‰¾ä¸‹ä¸€ä½
      const n=state.players.length;
      for (let step=1; step<=n; step++){
        const idx=(state.turnIndex+step)%n;
        const cand=state.players[idx];
        if (!cand.folded){ state.turnIndex=idx; break; }
      }
      render();
      maybeAutoTurn();
    }

    /***********************
     * æœºå™¨äººè¡Œä¸ºï¼ˆå«éšæœºå¼€ç‰Œï¼‰
     ***********************/
    function botStrength(p){
      const eva=evaluate3(p.hand);
      let minor=0;
      if (eva.scoreVec?.length) minor=eva.scoreVec.reduce((acc,v,i)=>acc+v*Math.pow(0.01,i),0);
      return eva.cat*100+minor;
    }
    function botAct(p){
      if (!state.inHand || state.showdown || p.folded) return;

      // éšè½®æ¬¡å¢å¤§çš„å¼€ç‰Œæ¦‚ç‡ï¼ˆæœºå™¨äººå¯ä¸»åŠ¨å‘èµ·æ‘Šç‰Œï¼‰
      const base = Math.min(0.05 + 0.03*(state.roundIndex-1), 0.5); // 5% èµ·ï¼Œé€è½® +3%ï¼Œæœ€å¤š 50%
      if (Math.random() < base){
        return showdown(`${p.name} å‘èµ·å¼€ç‰Œ`);
      }

      // æ™®é€šè·Ÿ/åŠ /å¼ƒ
      const need = Math.max(0, state.currentBet - p.betThisRound);
      const S=botStrength(p);
      const STRONG=500, MEDIUM=250;
      const canRaise = state.raisesThisRound < cfg.maxRaisesPerRound && p.chips > need + cfg.unitBet;

      if (S >= STRONG){
        if (canRaise){
          payToPot(p, need);
          state.currentBet += cfg.unitBet;
          state.raisesThisRound += 1;
          payToPot(p, cfg.unitBet);
          log(`${p.name}ï¼šåŠ æ³¨ï¼ˆå½“å‰éœ€è·Ÿæ³¨=${state.currentBet}ï¼‰`);
        }else{
          const paid=payToPot(p, need);
          log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
        }
      }else if (S >= MEDIUM){
        if (canRaise && Math.random()<0.25){
          payToPot(p, need);
          state.currentBet += cfg.unitBet;
          state.raisesThisRound += 1;
          payToPot(p, cfg.unitBet);
          log(`${p.name}ï¼šåŠ æ³¨ï¼ˆå½“å‰éœ€è·Ÿæ³¨=${state.currentBet}ï¼‰`);
        }else{
          const paid=payToPot(p, need);
          log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
        }
      }else{
        if (need>0 && Math.random()<0.5){
          p.folded=true; log(`${p.name}ï¼šå¼ƒç‰Œ`);
        }else{
          const paid=payToPot(p, need);
          log(`${p.name}ï¼šè·Ÿæ³¨ ï¿¥${paid}`);
        }
      }
      advanceTurn();
    }

    function maybeAutoTurn(){
      const p=state.players[state.turnIndex];
      if (p && !p.isHuman) setTimeout(()=>botAct(p), 600);
    }

    /***********************
     * æ‘Šç‰Œ & ç»“ç®—
     ***********************/
    function showdown(reason='å¼€ç‰Œ'){
      if (!state.inHand || state.showdown) return;
      state.inHand=false; state.showdown=true;
      log(`ã€${reason}ã€‘è¿›å…¥æ‘Šç‰Œ`);

      const alive=alivePlayers();
      let best=null, winners=[];
      for(const p of alive){
        const eva=evaluate3(p.hand);
        if (!best){ best={p,eva}; winners=[p]; }
        else{
          const cmp=compareHands(eva,best.eva);
          if (cmp>0){ best={p,eva}; winners=[p]; }
          else if (cmp===0){ winners.push(p); }
        }
      }
      if (winners.length===1){
        winners[0].chips += state.pot;
        log(`èµ¢å®¶ï¼š${winners[0].name}ï¼ˆ${evaluate3(winners[0].hand).name}ï¼‰ï¼Œèµ¢å¾— ï¿¥${state.pot}`);
      }else{
        const share=Math.floor(state.pot/winners.length);
        for(const w of winners) w.chips+=share;
        log(`å¹³åˆ†åº•æ± ï¼š${winners.map(w=>w.name).join('ã€')} å„å¾— ï¿¥${share}`);
      }
      state.pot=0;
      render();
      // æ˜¾ç¤ºâ€œä¸‹ä¸€å±€â€
      const btnNext = document.getElementById('btnNext');
      if (btnNext) btnNext.style.display='inline-block';
    }

    function winByFold(p){
      state.inHand=false; state.showdown=true;
      p.chips += state.pot;
      log(`å…¶ä½™ç©å®¶å¼ƒç‰Œï¼Œ${p.name} ç›´æ¥èµ¢å¾— ï¿¥${state.pot}`);
      state.pot=0;
      render();
      const btnNext=document.getElementById('btnNext');
      if (btnNext) btnNext.style.display='inline-block';
    }

    /***********************
     * å¯åŠ¨
     ***********************/
    document.getElementById('ante').textContent = cfg.ante;
    document.getElementById('unitBet').textContent = cfg.unitBet;
    document.getElementById('maxRaises').textContent = cfg.maxRaisesPerRound;
    document.getElementById('maxRounds').textContent = cfg.maxRounds;

    setupPlayers();
    newHand();
  </script>
</body>
</html>





